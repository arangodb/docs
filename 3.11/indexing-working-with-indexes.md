---
layout: default
description: Learn how to use different indexes efficiently by going through the ArangoDB Performance Course
---
Working with Indexes
====================

Learn how to use different indexes efficiently by going through the
[ArangoDB Performance Course](https://www.arangodb.com/arangodb-performance-course/){:target="_blank"}.

Index Identifiers
-----------------

An index identifier uniquely identifies an index within a collection.
It is a numeric value stored as a string that is auto-generated by ArangoDB.
It can be prefixed with a collection name and forward slash (`/`) to uniquely
identify an index within a database. 

A specific index of a collection can be accessed using its index identifier
as follows:

```js
db.collection.index("<index-identifier>");
db.collection.index("<collection-name>/<index-identifier>");
db._index("<collection-name>/<index-identifier>");
```

For example, assume that the full index identifier, which is stored in the `_id`
attribute of the index, is `demo/362549736`, and the index has been created in a
collection named `demo`. Then this index can be accessed as follows:

```js
db.demo.index("362549736");
db.demo.index("demo/362549736");
```

Because the full index identifier is unique within the database, you can also
access the index directly from the `db` object:

```js
db._index("demo/362549736");
```

You can also look up an index by its name. Since names are only unique within
a collection rather than within the database, the lookup must also include the
collection name when calling `db._index()`:

```js
db.demo.index("primary")
db._index("demo/primary")
```

Collection Methods
------------------

### Listing all indexes of a collection

`collection.getIndexes(withStats, withHidden)`

`collection.indexes(withStats, withHidden)`

Returns an array of all indexes defined for the collection.

You can set the following parameters:

- `withStats` (boolean, _optional_): whether to include index figures and
  estimates in the result. Default: `false`
- `withHidden` (boolean, _optional_): whether to include hidden indexes in the
  result. Default: `false`

The `indexes()` method is an alias for `getIndexes()`.

Note that `_key` implicitly has an index assigned to it.

**Examples**

Get the index definitions for a collection:

    {% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline collectionGetIndexes
    @EXAMPLE_ARANGOSH_OUTPUT{collectionGetIndexes}
    ~db._create("test");
    ~db.test.ensureIndex({ type: "persistent", fields: ["attribute"], unique: true });
    ~db.test.ensureIndex({ type: "persistent", fields: ["uniqueAttribute"], unique: true });
    ~db.test.ensureIndex({ type: "persistent", fields: ["attribute", "secondAttribute.subAttribute"] });
    db.test.getIndexes();
    ~db._drop("test");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock collectionGetIndexes
    {% endarangoshexample %}
    {% include arangoshexample.html id=examplevar script=script result=result %}

Get the index definitions for a collection, including figures and hidden indexes:

    {% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline collectionGetIndexesStats
    @EXAMPLE_ARANGOSH_OUTPUT{collectionGetIndexesStats}
    ~ db._create("coll");
    ~ db.coll.save({ attr: "foo" });
    ~ db.coll.save({ attr: "bar" });
    ~ db.coll.ensureIndex({ type: "inverted", fields: ["attr"], name: "inv-idx" });
    ~ db._createView("arangosearch-view", "arangosearch", { links: { coll: { includeAllFields: true } } });
    ~ assert(db._query(`FOR d in ´arangosearch-view´ COLLECT WITH COUNT INTO c RETURN c`).toArray()[0] === 2);
      db.coll.indexes(true, true);
    ~ db._drop("coll");
    ~ db._dropView("arangosearch-view");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock collectionGetIndexesStats
    {% endarangoshexample %}
    {% include arangoshexample.html id=examplevar script=script result=result %}

### Creating an index

Ensures that an index exists:

`collection.ensureIndex(index-description)`

Ensures that an index according to the `index-description` exists. A
new index will be created if none exists with the given description.

Calling this method returns an index object. Whether or not the index
object existed before the call is indicated in the `isNewlyCreated` return
attribute.

The `index-description` input value must contain at least a `type` attribute.
Other attributes may be necessary, depending on the index type.

- `type`: can be one of the following values:
  - `"persistent"`: persistent (array) index, including vertex-centric index
  - `"inverted"`: inverted index
  - `"ttl"`: time-to-live index
  - `"fulltext"`: full-text index (deprecated from ArangoDB 3.10 onwards)
  - `"geo"`: geo-spatial index, with _one_ or _two_ attributes
  - `"zkd"`: multi-dimensional index (experimental)

- `fields`: an array of attribute paths, containing the document attributes
  (or sub-attributes) to be indexed. Some indexes allow using only a single path,
  and others allow multiple. 
  If multiple attributes are used, their order matters.

  The `.` character denotes sub-attributes in attribute paths. Attributes with
  literal `.` in their name cannot be indexed. Attributes with the name `_id`
  cannot be indexed either, neither as a top-level attribute nor as a sub-attribute.

  If an attribute path contains an `[*]` extension (e.g. `friends[*].id`), it means
  that the index attribute value is treated as an array and all array members are
  indexed separately. This is possible with `persistent` and `inverted` indexes.

- `storedValues`: in indexes of type `persistent` and `inverted`, additional
  attributes can be stored in the index. These additional attributes cannot be used for
  index lookups or for sorting, but they can be used for projections. This allows an
  index to fully cover more queries and avoid extra document lookups.
  Non-existing attributes are stored as `null` values inside `storedValues`.
  The maximum number of attributes in `storedValues` is 32.
  It is not possible to create multiple indexes with the same `fields` attributes
  and uniqueness but different `storedValues` attributes. That means the value of 
  `storedValues` is not considered in index creation calls when checking if an 
  index is already present or needs to be created.
  In unique indexes, only the attributes in `fields` are checked for uniqueness,
  but the attributes in `storedValues` are not checked for their uniqueness.

- `name`: can be a string. Index names are subject to the same character
  restrictions as [collection names](data-modeling-collections.html#collection-names).
  If omitted, a name will be auto-generated so
  that it is unique with respect to the collection, e.g. `idx_832910498`.

  The purpose of user-defined index names is have easy-to-remember names to
  use in index hints in AQL queries.
  If no index hints are used, going with the auto-generated index names is fine.

- `sparse`: can be `true` or `false`.
  You can control the sparsity for `persistent` indexes. The `inverted`, `fulltext`,
  and `geo` index types are [sparse](indexing-which-index.html) by definition.

- `unique`: can be `true` or `false` and is supported by `persistent` indexes.
  By default, all user-defined indexes are non-unique.
  Only the attributes in `fields` are checked for uniqueness. Any attributes in
  from `storedValues` are not checked for their uniqueness.

- `deduplicate`: can be `true` or `false` and is supported by array indexes of
  type `persistent`. It controls whether inserting duplicate index values
  from the same document into a unique array index will lead to a unique constraint
  error or not. The default value is `true`, so only a single instance of each
  non-unique index value will be inserted into the index per document. Trying to
  insert a value into the index that already exists in the index will always fail,
  regardless of the value of this attribute.

- `estimates`: can be `true` or `false` and is supported by indexes of type
  `persistent`. This attribute controls whether index selectivity estimates are
  maintained for the index. Not maintaining index selectivity estimates can have
  a slightly positive impact on write performance.
  The downside of turning off index selectivity estimates will be that
  the query optimizer will not be able to determine the usefulness of different
  competing indexes in AQL queries when there are multiple candidate indexes to
  choose from.
  The `estimates` attribute is optional and defaults to `true` if not set. It will
  have no effect on indexes other than `persistent` (with `hash` and `skiplist`
  being mere aliases for the `persistent` index type nowadays).

- `cacheEnabled`: can be `true` or `false` and is supported by indexes of type
  `persistent`. The attribute controls whether an extra in-memory hash cache is
  created for the index. The hash cache can be used to speed up index lookups.
  The cache can only be used for queries that look up all index attributes via
  an equality lookup (`==`). The hash cache cannot be used for range scans, 
  partial lookups or sorting.
  The cache will be populated lazily upon reading data from the index. Writing data
  into the collection or updating existing data will invalidate entries in the
  cache. The cache may have a negative effect on performance in case index values
  are updated more often than they are read.
  The maximum size of cache entries that can be stored is currently 4 MB, i.e.
  the cumulated size of all index entries for any index lookup value must be
  less than 4 MB. This limitation is there to avoid storing the index entries
  of "super nodes" in the cache.
  `cacheEnabled` defaults to `false` and should only be used for indexes that
  are known to benefit from an extra layer of caching.

Also check the documentation of the specific index type for additional options.

**Examples**

{% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline collectionEnsureIndex
    @EXAMPLE_ARANGOSH_OUTPUT{collectionEnsureIndex}
    ~db._create("test");
    db.test.ensureIndex({ type: "persistent", fields: [ "a" ], sparse: true });
    db.test.ensureIndex({ type: "persistent", fields: [ "a", "b" ], unique: true });
    ~db._drop("test");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock collectionEnsureIndex
{% endarangoshexample %}
{% include arangoshexample.html id=examplevar script=script result=result %}


### Dropping an index via a collection object

`collection.dropIndex(index)`

Delete the specified index using an index object.

If the index does not exist or cannot be dropped, then an error is raised.
If the index existed and has been dropped, then `true` is returned.

Note that you cannot drop certain indexes (e.g. the primary index of a
collection or the edge index of an edge collection).

---

`collection.dropIndex(index-identifier)`

Delete the specified index using an index identifier.

{% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline col_dropIndex
    @EXAMPLE_ARANGOSH_OUTPUT{col_dropIndex}
    ~db._create("example");
    var idx1 = db.example.ensureIndex({ type: "persistent", fields: ["a", "b"] });
    var idx2 = db.example.ensureIndex({ type: "persistent", fields: ["c"] });
    var indexInfo = db.example.getIndexes();
    indexInfo;
    db.example.dropIndex(indexInfo[1])
    db.example.dropIndex(indexInfo[2].id)
    indexInfo = db.example.getIndexes();
    ~db._drop("example");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock col_dropIndex
{% endarangoshexample %}
{% include arangoshexample.html id=examplevar script=script result=result %}

### Load Indexes into Memory

Loads suitable indexes of this collection into memory:

`collection.loadIndexesIntoMemory()`

This function tries to cache index entries of this collection in main memory.
Index lookups that can be served from the memory cache can be much faster
than lookups not stored in the cache, so you can get a nice performance boost.

The function iterates over suitable indexes of the collection and stores the 
indexed values, not the entire document data, in memory.
This is implemented for edge indexes only.

The function returns as soon as the index warmup has been scheduled. The index
warmup may still be ongoing in the background, even after the function has already
returned. As all suitable indexes are scanned, it may cause significant
I/O activity and background load.

This function honors memory limits. If the indexes you want to load are smaller
than your memory limit, this function guarantees that most index values are
cached. If the index is larger than your memory limit, this function fills
up values up to this limit and there is no way to control
which indexes of the collection should have priority over others.

It is guaranteed at all times that the in-memory cache data is consistent with 
the stored index data.

{% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline LoadIndexesIntoMemory
    @EXAMPLE_ARANGOSH_OUTPUT{loadIndexesIntoMemory}
    ~db._drop("example");
    ~db._createEdgeCollection("example");
    db.example.loadIndexesIntoMemory();
    ~db._drop("example");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock LoadIndexesIntoMemory
{% endarangoshexample %}
{% include arangoshexample.html id=examplevar script=script result=result %}

Database Methods
----------------

### Fetching an index by identifier

`db._index(index-identifier)`

Find and return the specified index, or `null` if no such index exists.

{% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline IndexIdentifier
    @EXAMPLE_ARANGOSH_OUTPUT{IndexIdentifier}
    ~db._create("example");
    db.example.ensureIndex({ type: "persistent", fields: [ "a", "b" ] });
    var indexInfo = db.example.getIndexes().map(function(x) { return x.id; });
    indexInfo;
    db._index(indexInfo[0])
    db._index(indexInfo[1])
    ~db._drop("example");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock IndexIdentifier
{% endarangoshexample %}
{% include arangoshexample.html id=examplevar script=script result=result %}

### Dropping an index via a database object

`db._dropIndex(index)`

Delete the specified index using an index object.

If the index does not exist or cannot be dropped, an error is raised.
If the index existed and has been dropped, then `true` is returned.

---

`db._dropIndex(index-identifier)`

Drop the specified index using an index identifier.

{% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline dropIndex
    @EXAMPLE_ARANGOSH_OUTPUT{dropIndex}
    ~db._create("example");
    var idx1 = db.example.ensureIndex({ type: "persistent", fields: [ "a", "b" ] });
    var idx2 = db.example.ensureIndex({ type: "persistent", fields: [ "c" ] });
    var indexInfo = db.example.getIndexes();
    indexInfo;
    db._dropIndex(indexInfo[1])
    db._dropIndex(indexInfo[2].id)
    indexInfo = db.example.getIndexes();
    ~db._drop("example");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock dropIndex
{% endarangoshexample %}
{% include arangoshexample.html id=examplevar script=script result=result %}

### Revalidating whether an index is used

So you've created an index, and since its maintenance isn't for free,
you definitely want to know whether your query can utilize it.

You can use explain to verify that a certain index is used:

{% arangoshexample examplevar="examplevar" script="script" result="result" %}
    @startDocuBlockInline IndexVerify
    @EXAMPLE_ARANGOSH_OUTPUT{IndexVerify}
    ~db._create("example");
    var explain = require("@arangodb/aql/explainer").explain;
    var idx = db.example.ensureIndex({ type: "persistent", fields: [ "a", "b" ] });
    explain("FOR doc IN example FILTER doc.a < 23 RETURN doc", {colors: false});
    ~db._drop("example");
    @END_EXAMPLE_ARANGOSH_OUTPUT
    @endDocuBlock IndexVerify
{% endarangoshexample %}
{% include arangoshexample.html id=examplevar script=script result=result %}

You can omit `colors: false` to get syntax highlighting in _arangosh_.
